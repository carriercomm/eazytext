
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><body><div class="wikiblk"><div name="TOC" style="float : left; padding-bottom : 3px; margin-bottom : 10px; margin-top : 10px; padding-right : 3px; margin-left : 10px; background : #f8f7bc; margin-right : 10px; position : relative; padding-top : 3px; font-family : arial,sans-serif; padding-left : 3px"><div style="margin-left : 1em;"><a href="#GNU Compiler Collection">GNU Compiler Collection</a></div><div style="margin-left : 2em;"><a href="#Structure">Structure</a></div><div style="margin-left : 3em;"><a href="#Front-ends">Front-ends</a></div><div style="margin-left : 3em;"><a href="#Optimization">Optimization</a></div><div style="margin-left : 3em;"><a href="#Back-end">Back-end</a></div><div style="margin-left : 2em;"><a href="#Debugging GCC programs">Debugging GCC programs</a></div><div style="margin-left : 2em;"><a href="#License">License</a></div></div><div style="white-space : normal; font-size : 90%; font-family : arial,sans-serif;">

<p><style type="text/css">
h1, h2, h3, h4, h5 { 
    color : #003366;
    margin : 0px;
    padding: 5px 0px 2px 3px;
    width : 100%;
    border-bottom: 1px solid gray;
}
</style>
</p>
<p>
</p>
<p><div style="float : right; color : blue; border-left : thin solid #CEF2E0; border-bottom : thin solid #CEF2E0; width : 40%; border-top : thin solid #CEF2E0; border-right : thin solid #CEF2E0; position : relative; margin : 10px 2px 10px 5px;"><div style="color : ; margin-bottom : 5px; padding-right : 3px; background : #CEF2E0; padding-bottom : 3px; padding-top : 3px; font-weight : bold; padding-left : 3px">GNU compiler project</div><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;">
<p><strong>Developed by</strong>     : GNU Project <br />
<strong>Initial release</strong>  : May 23, 1987 (1987-05-23)[1] <br />
<strong>Latest release</strong>   : 4.4.0 / 2009-04-21; 21 days ago <br />
<strong>Operating system</strong> : Cross-platform <br />
<strong>Platform</strong>         : GNU <br />
<strong>Type</strong>             : Compiler <br />
<strong>License</strong>          : GNU General Public License, GNU Lesser General Public License <br />
<strong>Website</strong>          :  <a href="http://gcc.gnu.org">http://gcc.gnu.org</a> <br />
</p>
</div></div></div></p>
<p><div style="clear : both"></div>
</p>

<p><h2> GNU Compiler Collection<a style="visibility : hidden;" name="GNU Compiler Collection">&#167;</a></h2>
</p>

<p><h3> Structure<a style="visibility : hidden;" name="Structure">&#167;</a></h3>
</p>
<p>GCC's external interface is generally standard for a UNIX compiler. Users invoke a driver program named gcc, which interprets command arguments, decides which language compilers to use for each input file, runs the assembler on their output, and then possibly runs the linker to produce a complete executable binary.
</p>
<p>Each of the language compilers is a separate program that inputs source code and outputs assembly code. All have a common internal structure. A per-language front end parses the source code in that language and produces an abstract syntax tree (&quot;tree&quot; for short).
</p>
<p>These are if necessary converted to the middle-end's input representation, called GENERIC form; the middle-end then gradually transforms the program towards its final form. <a href="file9">Compiler optimizations</a> and static code analysis techniques (such as FORTIFY_SOURCE,[16] a compiler directive which attempts to discover some buffer overflows) are applied to the code. These work on multiple representation, mostly the architecture-independent GIMPLE representation and the architecture-dependent RTL representation. Finally, assembly language is produced using architecture-specific pattern matching originally based on an algorithm of Jack Davidson and Chris Fraser.
</p>
<p>GCC is written primarily in C except for parts of the Ada front end. The distribution includes the standard libraries for Ada, C++, and Java whose code is mostly written in those languages.[17]
</p>
<p><h4> Front-ends<a style="visibility : hidden;" name="Front-ends">&#167;</a></h4>
</p>
<p>Frontends vary internally, having to produce trees that can be handled by the backend. Currently, the parsers are all hand-coded recursive descent parsers, though there is no reason why a parser generator could not be used for new front-ends in the future.
</p>
<p>Until recently, the tree representation of the program was not fully independent of the processor being targeted. Confusingly, the meaning of a tree was somewhat different for different language front-ends, and front-ends could provide their own tree codes. This was simplified with the introduction of GENERIC (more complex, based on the GCC 3.x Java front-end's intermediate representation) and GIMPLE (a simplified GENERIC, in which various constructs are lowered to multiple GIMPLE instructions), two new forms of language-independent trees that were introduced in 2005 with the advent of GCC 4.0. The C, C++ and Java front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC.
</p>
<p>In either case, the so-called &quot;gimplifier&quot; then lowers this more complex form into the simpler SSA-based GIMPLE form which is the common language for a large number of new powerful language- and architecture-independent global (function scope) optimizations.
</p>
<p><h4> Optimization<a style="visibility : hidden;" name="Optimization">&#167;</a></h4>
</p>
<p>Optimization on trees does not generally fit into what most compiler developers would consider a front end task, as it is not language dependent and does not involve parsing. A common, even though somewhat contradictory, name for this part of the compiler is &quot;middle end.&quot;
</p>
<p>The exact set of GCC optimizations varies from release to release as it develops, but includes the standard algorithms, such as loop optimization, jump threading, common subexpression elimination, instruction scheduling, and so forth. The RTL optimizations are of less importance with the addition of global SSA-based optimizations on GIMPLE trees,[18] as RTL optimizations have a much more limited scope, and have less high-level information.
</p>
<p>Some of these optimizations performed at this level include dead code elimination, partial redundancy elimination, global value numbering, sparse conditional constant propagation, and scalar replacement of aggregates. Array dependence based optimizations such as automatic vectorization and automatic parallelization are also performed. Profile-guided optimization is also possible as demonstrated here: <a href="http://gcc.gnu.org/install/build.html#TOC4">http://gcc.gnu.org/install/build.html#TOC4</a>
</p>
<p><h4> Back-end<a style="visibility : hidden;" name="Back-end">&#167;</a></h4>
</p>
<p>The behavior of GCC's back end is partly specified by preprocessor macros and functions specific to a target architecture, for instance to define the endianness, word size, and calling conventions. The front part of the back end uses these to help decide RTL generation, so although GCC's RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have to comply with the machine description of the target architecture.
</p>
<p>Towards the end of compilation, valid RTL is further reduced to a strict form in which each instruction refers to real machine registers and real instructions from the target's instruction set. Forming strict RTL is a very complicated task, done mostly by the register allocation first but completed only by a separate &quot;reloading&quot; phase which must account for the vagaries of all of GCC's targets.
</p>
<p>The final phase is somewhat anticlimactic, because the patterns to match were generally chosen during reloading, and so the assembly code is simply built by running substitutions of registers and addresses into the strings specifying the instructions.
</p>
<p><h3> Debugging GCC programs<a style="visibility : hidden;" name="Debugging GCC programs">&#167;</a></h3>
</p>
<p>The primary tool used to debug GCC code is the GNU Debugger (gdb). Among more specialized tools are Valgrind for finding memory errors and leaks. The GNU Profiler (gprof) can determine how much time is spent in which routines, and how often they are called; this requires programs to be compiled with profiling options.
</p>
<p><h3> License<a style="visibility : hidden;" name="License">&#167;</a></h3>
</p>
<p>&quot;GCC 4.2.1 was the last release of GCC covered by version 2 of the GNU General Public License. All subsequent releases are released under GPL version 3.&quot; [19]
</p>

</div></div></body></html>