
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><body><div class="wikiblk"><div name="TOC" style="float : left; padding-bottom : 3px; margin-bottom : 10px; margin-top : 10px; padding-right : 3px; margin-left : 10px; background : #f8f7bc; margin-right : 10px; position : relative; padding-top : 3px; padding-left : 3px"><div style="margin-left : 2px; "><a href="#Python Library Modules">Python Library Modules</a></div><div style="margin-left : 2em;"><a href="#The itertools module">The itertools module</a></div><div style="margin-left : 3em;"><a href="#Creating new iterators">Creating new iterators</a></div><div style="margin-left : 3em;"><a href="#Calling functions on elements">Calling functions on elements</a></div><div style="margin-left : 3em;"><a href="#Selecting elements">Selecting elements</a></div><div style="margin-left : 3em;"><a href="#Grouping elements">Grouping elements</a></div><div style="margin-left : 2em;"><a href="#The functools module">The functools module</a></div><div style="margin-left : 3em;"><a href="#The operator module">The operator module</a></div><div style="margin-left : 3em;"><a href="#The functional module">The functional module</a></div></div><div style="white-space : normal; font-size : 100%; font-family : tahoma,sans-serif;">
<p><style type="text/css">
h1, h2, h3, h4, h5 { 
    margin : 0px;
    padding: 5px 0px 2px 3px;
    background-color : #EAEAFC;
    width : 100%;
    border-top: thin solid blue;
}
</style>
</p>
<p>
</p>
<p><div style="clear : both"></div>
</p>

<p><h1> Python Library Modules<a style="visibility : hidden;" name="Python Library Modules">&#167;</a></h1>
</p>
<p><h3> The itertools module<a style="visibility : hidden;" name="The itertools module">&#167;</a></h3>
</p>
<p>The itertools module contains a number of commonly-used iterators as well as functions for combining several iterators. This section will introduce the module's contents by showing small examples.
</p>
<p>The module's functions fall into a few broad classes:
</p>
<p><ol><li> Functions that create a new iterator based on an existing iterator.</li><li> Functions for treating an iterator's elements as function arguments.</li><li> Functions for selecting portions of an iterator's output.</li><li> A function for grouping an iterator's output.</li></ol></p>
<p><h4> Creating new iterators<a style="visibility : hidden;" name="Creating new iterators">&#167;</a></h4>
</p>
<p><table border="1" cellspacing="0" cellpadding="3px" ><tr><td> <strong><u> itertool function </u></strong>  </td><td> <strong><u>Purpose </u></strong></td>
</tr><tr><td> <a href=" #anchor count ">count()</a></td><td>  returns an infinite stream of integers, increasing by 1 each time</td>
</tr><tr><td> <a href=" #anchor cycle ">cycle()</a></td><td>  returns a new iterator that returns its elements from first to last.</td>
</tr><tr><td> <a href=" #anchor repeat ">repeat()</a></td><td> returns the provided element n times</td>
</tr><tr><td> <a href=" #anchor chain ">chain()</a></td><td> takes an arbitrary number of iterables as input, and returns all the elements</td>
</tr><tr><td> <a href=" #anchor izip ">izip()</a></td><td> takes one element from each iterable and returns them in a tuple</td>
</tr><tr><td> <a href=" #anchor islice ">islice()</a></td><td> returns a stream that?s a slice of the iterator</td>
</tr><tr><td><a href=" #anchor tee ">tee()</a></td><td> replicates an iterator</td>
</tr></table></p>

<p><ul><li> <strong>itertools.count(n) </strong>  <a name="anchor count" style="font-weight : bold"> </a></li></ul></p><p> returns an infinite stream of integers, increasing by 1 each time. You can optionally supply the starting number, which defaults to 0:
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.count() =&gt; <br />
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ... <br />
itertools.count(10) =&gt; <br />
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ... <br />
</p>
</div></div></div></p>

<p><ul><li> <strong>itertools.cycle(iter)</strong> <a name="anchor cycle" style="font-weight : bold"> </a></li></ul></p><p> saves a copy of the contents of a provided iterable and returns a new iterator that returns its elements from first to last. The new iterator will repeat these elements infinitely.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Fixed width; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.cycle([1,2,3,4,5]) =&gt;
  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
</p>
</div></div></div></p>
<p><ul><li> <strong>itertools.repeat(elem, [n])</strong>  <a name="anchor repeat" style="font-weight : bold"> </a></li></ul></p><p>returns the provided element n times, or returns the element endlessly if n is not provided.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.repeat('abc') =&gt; <br />
  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ... <br />
itertools.repeat('abc', 5) =&gt; <br />
  abc, abc, abc, abc, abc <br />
</p>
</div></div></div></p>
<p><ul><li><strong>itertools.chain(iterA, iterB, ...)</strong> <a name="anchor chain" style="font-weight : bold"> </a></li></ul></p><p> takes an arbitrary number of iterables as input, and returns all the elements of the first iterator, then all the elements of the second, and so on, until all of the iterables have been exhausted.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =&gt; <br />
  a, b, c, 1, 2, 3 <br />
</p>
</div></div></div></p>
<p><ul><li> <strong> itertools.izip(iterA, iterB, ...) </strong> <a name="anchor izip" style="font-weight : bold"> </a></li></ul></p><p> takes one element from each iterable and returns them in a tuple:
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.izip(['a', 'b', 'c'], (1, 2, 3)) =&gt; <br />
  ('a', 1), ('b', 2), ('c', 3) <br />
</p>
</div></div></div></p>
<p>It's similar to the built-in <strong><em> zip() </em></strong> function, but doesn't construct an in-memory list and exhaust all the input iterators before returning; instead tuples are constructed and returned only if they're requested. (The technical term for this behaviour is lazy evaluation.)
</p>
<p>This iterator is intended to be used with iterables that are all of the same length. If the iterables are of different lengths, the resulting stream will be the same length as the shortest iterable.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.izip(['a', 'b'], (1, 2, 3)) =&gt; <br />
  ('a', 1), ('b', 2) <br />
</p>
</div></div></div></p>
<p>You should avoid doing this, though, because an element may be taken from the longer iterators and discarded. This means you can't go on to use the iterators further because you risk skipping a discarded element.
</p>
<p><ul><li> <strong>itertools.islice(iter, [start], stop, [step]) </strong> <a name="anchor islice" style="font-weight : bold"> </a></li></ul></p><p> returns a stream that's a slice of the iterator. With a single stop argument, it will return the first stop elements. If you supply a starting index, you'll get stop-start elements, and if you supply a value for step, elements will be skipped accordingly. Unlike Python's string and list slicing, you can't use negative values for start, stop, or step.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.islice(range(10), 8) =&gt; <br />
  0, 1, 2, 3, 4, 5, 6, 7 <br />
itertools.islice(range(10), 2, 8) =&gt; <br />
  2, 3, 4, 5, 6, 7 <br />
itertools.islice(range(10), 2, 8, 2) =&gt; <br />
  2, 4, 6 <br />
</p>
</div></div></div></p>
<p><ul><li> <strong> itertools.tee(iter, [n]) </strong>  <a name="anchor tee" style="font-weight : bold"> </a></li></ul></p>
<p>replicates an iterator; it returns n independent iterators that will all return the contents of the source iterator. If you don't supply a value for n, the default is 2. Replicating iterators requires saving some of the contents of the source iterator, so this can consume significant memory if the iterator is large and one of the new iterators is consumed more than the others.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>itertools.tee( itertools.count() ) =&gt; <br />
   iterA, iterB <br />
</p>
<p>where iterA -&gt; <br />
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ... <br />
</p>
<p>and   iterB -&gt; <br />
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ... <br />
</p>

</div></div></div></p>
<p><h4> Calling functions on elements<a style="visibility : hidden;" name="Calling functions on elements">&#167;</a></h4>
</p>
<p>Two functions are used for calling other functions on the contents of an iterable.
</p>
<p><ul><li> <strong> itertools.imap(f, iterA, iterB, ...) </strong> returns a stream containing f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...:</li></ul></p>
<p>itertools.imap(operator.add, [5, 6, 5], [1, 2, 3]) =&gt; <br></br>
  6, 8, 8 <br></br>
</p>
<p>The operator module contains a set of functions corresponding to Python's operators. Some examples are operator.add(a, b) (adds two values), operator.ne(a, b) (same as a!=b), and operator.attrgetter('id') (returns a callable that fetches the &quot;id&quot; attribute).
</p>
<p><ul><li> <strong>itertools.starmap(func, iter) </strong> assumes that the iterable will return a stream of tuples, and calls f() using these tuples as the arguments:</li></ul></p>
<p>itertools.starmap(os.path.join, <br></br>
                  [(<strong><em>usr', 'bin', 'java'), (</em></strong>bin', 'python'), <br></br>
                   (<strong><em>usr', 'bin', 'perl'),(</em></strong>usr', 'bin', 'ruby') ] )  =&gt; <br></br>
   /usr/bin/java, /bin/python, /usr/bin/perl, /usr/bin/ruby <br></br>
</p>
<p><h4> Selecting elements<a style="visibility : hidden;" name="Selecting elements">&#167;</a></h4>
</p>
<p>Another group of functions chooses a subset of an iterator's elements based on a predicate.
</p>
<p><ul><li> <strong> itertools.ifilter(predicate, iter) </strong> returns all the elements for which the predicate returns true:</li></ul></p>
<p>def is_even(x):
    return (x % 2) == 0
</p>
<p>itertools.ifilter(is_even, itertools.count()) =&gt; <br></br>
  0, 2, 4, 6, 8, 10, 12, 14, ... <br></br>
</p>
<p><ul><li> <strong> itertools.ifilterfalse(predicate, iter) </strong> is the opposite, returning all elements for which the predicate returns false:</li></ul></p>
<p>itertools.ifilterfalse(is_even, itertools.count()) =&gt; <br></br>
  1, 3, 5, 7, 9, 11, 13, 15, ... <br></br>
</p>
<p><ul><li> <strong> itertools.takewhile(predicate, iter) </strong> returns elements for as long as the predicate returns true. Once the predicate returns false, the iterator will signal the end of its results.</li></ul></p>
<p>def less_than_10(x):
    return (x &lt; 10)
</p>
<p>itertools.takewhile(less_than_10, itertools.count()) =&gt;
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9
</p>
<p>itertools.takewhile(is_even, itertools.count()) =&gt;
  0
</p>
<p><ul><li> <strong> itertools.dropwhile(predicate, iter) </strong> discards elements while the predicate returns true, and then returns the rest of the iterable's results.</li></ul></p>
<p>itertools.dropwhile(less_than_10, itertools.count()) =&gt;
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...
</p>
<p>itertools.dropwhile(is_even, itertools.count()) =&gt;
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...
</p>
<p><h4> Grouping elements<a style="visibility : hidden;" name="Grouping elements">&#167;</a></h4>
</p>
<p>The last function I'll discuss, <strong><em> itertools.groupby(iter, key_func=None) </em></strong>, is the most complicated. key_func(elem) is a function that can compute a key value for each element returned by the iterable. If you don't supply a key function, the key is simply each element itself.
</p>
<p><strong>groupby() </strong> collects all the consecutive elements from the underlying iterable that have the same key value, and returns a stream of 2-tuples containing a key value and an iterator for the elements with that key.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'), <br />
             ('Anchorage', 'AK'), ('Nome', 'AK'), <br />
             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'), <br />
             ... <br />
            ] <br />
</p>
<p>def get_state ((city, state)): <br />
    return state <br />
</p>
<p>itertools.groupby(city_list, get_state) =&gt; <br />
  ('AL', iterator-1), <br />
  ('AK', iterator-2), <br />
  ('AZ', iterator-3), ... <br />
</p>
<p>where
iterator-1 =&gt; <br />
  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL') <br />
iterator-2 =&gt; <br />
  ('Anchorage', 'AK'), ('Nome', 'AK') <br />
iterator-3 =&gt; <br />
  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ') <br />
</p>
</div></div></div></p>
<p><strong> groupby() </strong> assumes that the underlying iterable's contents will already be sorted based on the key. Note that the returned iterators also use the underlying iterable, so you have to consume the results of iterator-1 before requesting iterator-2 and its corresponding key.
</p>
<p><h3> The functools module<a style="visibility : hidden;" name="The functools module">&#167;</a></h3>
</p>
<p>The functools module in Python 2.5 contains some higher-order functions. A higher-order function takes one or more functions as input and returns a new function. The most useful tool in this module is the functools.partial() function.
</p>
<p>For programs written in a functional style, you'll sometimes want to construct variants of existing functions that have some of the parameters filled in. Consider a Python function f(a, b, c); you may wish to create a new function g(b, c) that's equivalent to f(1, b, c); you're filling in a value for one of f()'s parameters. This is called 'partial function application'.
</p>
<p>The constructor for partial takes the arguments <em> (function, arg1, arg2, ... kwarg1=value1, kwarg2=value2) </em>. The resulting object is callable, so you can just call it to invoke function with the filled-in arguments.
</p>
<p>Here's a small but realistic example:
</p>
<p><div style="float : none; color : green; border-left : thin solid #CEF2E0; pos : normal; border-bottom : thin solid #CEF2E0; width : 50%; border-top : thin solid #CEF2E0; border-right : thin solid #CEF2E0; position : relative"><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>import functools <br />
</p>
<p>def log (message, subsystem): <br />
    "Write the contents of 'message' to the specified subsystem." <br />
    print '%s: %s' % (subsystem, message) <br />
    ...
</p>
<p>server_log = functools.partial(log, subsystem='server') <br />
server_log('Unable to open socket') <br />
</p>
</div></div></div></p>
<p><h4> The operator module<a style="visibility : hidden;" name="The operator module">&#167;</a></h4>
</p>
<p>The operator module was mentioned earlier. It contains a set of functions corresponding to Python's operators. These functions are often useful in functional-style code because they save you from writing trivial functions that perform a single operation.
</p>
<p>Some of the functions in this module are:
</p>
<p><ul><li> Math operations: </li><ul><li>add(),</li><li>sub(),</li><li> mul(),</li><li> div(),</li><li> floordiv(),</li><li> abs(), </li></ul><li> Logical operations: </li><ul><li> not_(), </li><li> truth().</li></ul><li> Bitwise operations: </li><ul><li>and_(),</li><li> or_(),</li><li> invert().</li></ul><li> Comparisons:</li><ul><li> eq(),</li><li> ne(),</li><li> lt(),</li><li> le(),</li><li> gt(),</li><li> ge().</li></ul><li> Object identity: </li><ul><li> is_(),</li><li> is_not().</li></ul></ul></p>
<p>Consult the operator module's documentation for a complete list.
</p>
<p><h4> The functional module<a style="visibility : hidden;" name="The functional module">&#167;</a></h4>
</p>
<p>Collin Winter's <strong><em> functional module </em></strong> provides a number of more advanced tools for functional programming. It also reimplements several Python built-ins, trying to make them more intuitive to those used to functional programming in other languages.
</p>
<p>This section contains an introduction to some of the most important functions in functional; full documentation can be found at the <u> project's website </u>
</p>
<p><strong><em> compose(outer, inner, unpack=False) </em></strong>
</p>
<p>The <strong><em> compose() </em></strong> function implements function composition. In other words, it returns a wrapper around the outer and inner callables, such that the return value from inner is fed directly to outer. That is,
</p>
<p>&gt;&gt;&gt; def add(a, b): <br></br>
...     return a + b <br></br>
... <br></br>
&gt;&gt;&gt; def double(a): <br></br>
...     return 2 * a <br></br>
... <br></br>
&gt;&gt;&gt; compose(double, add)(5, 6) <br></br>
22 <br></br>
</p>
<p>is equivalent to
</p>
<p>&gt;&gt;&gt; double(add(5, 6)) <br></br>
22 <br></br>
</p>
<p>The <strong><em> unpack </em></strong> keyword is provided to work around the fact that Python functions are not always fully curried. By default, it is expected that the inner function will return a single object and that the outer function will take a single argument. Setting the unpack argument causes compose to expect a tuple from inner which will be expanded before being passed to outer. Put simply,
</p>
<p><strong><em> compose(f, g)(5, 6) </em></strong>
</p>
<p>is equivalent to:
</p>
<p><strong><em> f(g(5, 6)) </em></strong>
</p>
<p>while
</p>
<p><strong><em> compose(f, g, unpack=True)(5, 6) </em></strong>
</p>
<p>is equivalent to:
</p>
<p><strong><em> f(*g(5, 6)) </em></strong>
</p>
<p>Even though compose() only accepts two functions, it's trivial to build up a version that will compose any number of functions. We'll use reduce(), compose() and partial() (the last of which is provided by both functional and functools).
</p>
<p>from functional import compose, partial
</p>
<p>multi_compose = partial(reduce, compose)
</p>
<p>We can also use map(), compose() and partial() to craft a version of &quot;&quot;.join(...) that converts its arguments to string:
</p>
<p>from functional import compose, partial 
</p>
<p>join = compose(&quot;&quot;.join, partial(map, str))
</p>
<p><strong><em> flip(func) </em></strong>
</p>
<p><strong><em> flip() </em></strong> wraps the callable in func and causes it to receive its non-keyword arguments in reverse order.
</p>
<p><div style="font-size : 80%; float : none; color : black; border-left : thin solid #CEF2E0; border-bottom : thin solid green; width : 100%; border-top : thin solid green; border-right : thin solid #CEF2E0; position : relative; font-family : Courier New; background-color : Azure "><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>&gt;&gt;&gt; def triple(a, b, c): <br />
...     return (a, b, c) <br />
... <br />
&gt;&gt;&gt; triple(5, 6, 7) <br />
(5, 6, 7) <br />
&gt;&gt;&gt; <br />
&gt;&gt;&gt; flipped_triple = flip(triple) <br />
&gt;&gt;&gt; flipped_triple(5, 6, 7) <br />
(7, 6, 5) <br />
</p>
</div></div></div></p>
<p>foldl(func, start, iterable)
</p>
<p>foldl() takes a binary function, a starting value (usually some kind of 'zero'), and an iterable. The function is applied to the starting value and the first element of the list, then the result of that and the second element of the list, then the result of that and the third element of the list, and so on.
</p>
<p>This means that a call such as:
</p>
<p><strong><em>  foldl(f, 0, [1, 2, 3]) </em></strong> 
</p>
<p>is equivalent to:
</p>
<p><strong><em>  f(f(f(0, 1), 2), 3) </em></strong> 
</p>
<p><strong><em>  foldl() </em></strong>  is roughly equivalent to the following recursive function:
</p>
<p><div style="float : none; color : green; border-left : thin solid #CEF2E0; pos : normal; border-bottom : thin solid #CEF2E0; width : 50%; border-top : thin solid #CEF2E0; border-right : thin solid #CEF2E0; position : relative"><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;"><p>def foldl(func, start, seq):
    if len(seq) == 0:
        return start
</p>
<p>    return foldl(func, func(start, seq[0]), seq[1:])
</p>

</div></div></div></p>
<p>Speaking of equivalence, the above foldl call can be expressed in terms of the built-in reduce like so:
</p>
<p><strong><em> reduce(f, [1, 2, 3], 0) </em></strong>
</p>
<p>We can use foldl(), operator.concat() and partial() to write a cleaner, more aesthetically-pleasing version of Python's &quot;&quot;.join(...) idiom:
</p>
<p><div style="float : none; color : green; border-left : thin solid #CEF2E0; pos : normal; border-bottom : thin solid #CEF2E0; width : 50%; border-top : thin solid #CEF2E0; border-right : thin solid #CEF2E0; position : relative"><div class="wikiblk"><div style="padding-top : 3px; padding-right : 3px; padding-left : 3px; padding-bottom : 3px;">
<p>// from functional import foldl, partial from operator import concat
</p>
<p>join = partial(foldl, concat, "") //
</p>
</div></div></div></p>
</div></div></body></html>